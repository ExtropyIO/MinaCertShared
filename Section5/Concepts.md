# zkApp Execution 



**1. User Interaction:**

- A user interacts with a zkApp through a user interface (UI), typically within a web browser.
- The user provides inputs to the zkApp, which could include data like account balances, transaction amounts, or other relevant information.

**2. Off-chain Execution:**

- The zkApp's logic, defined as a zero-knowledge circuit using 01JS, executes within the user's browser. This is off-chain execution.
- The circuit takes the user's inputs and performs the necessary computations.

**3. Proof Generation:**

- After the computation is complete, the zkApp generates a zero-knowledge proof using the Kimchi proof system. This proof demonstrates that the computation was performed correctly without revealing the private inputs or intermediate values.

**4. Proof Submission:**

- The user submits the proof, along with any necessary public inputs, to the Mina blockchain as a transaction.

**5. On-chain Verification:**

- Mina's validators verify the proof using the corresponding verifier function, which is a concise representation of the circuit's constraints.
- Verification ensures that the computation was performed correctly and the state transition is valid.

**6. State Update:**

- If the proof is valid, the Mina blockchain updates its state accordingly. This could involve transferring tokens, updating account balances, or modifying other on-chain data.

**Key Features of zkApp Execution:**

- **Privacy:** Private inputs and intermediate values remain hidden throughout the process, preserving user privacy.
- **Efficiency:** Off-chain execution minimises on-chain computation, leading to lower transaction fees and faster processing times.
- **Scalability:** zkApps can perform complex computations without burdening the blockchain, enabling more sophisticated applications.
- **Succinctness:** Zero-knowledge proofs are compact, reducing the amount of data that needs to be stored and transmitted.

**Example:**

Imagine a zkApp for private voting. Users can cast their votes through the zkApp UI. The circuit would ensure that each user votes only once and that their vote remains secret. The proof submitted to the blockchain would only reveal the final tally of votes, not the individual choices.

**In summary, zkApp execution in Mina combines off-chain computation with on-chain verification using zero-knowledge proofs. This approach provides a powerful and efficient way to build privacy-preserving decentralised applications.**


# Circuits

## How are circuits made 


- **zkApps:** Mina's smart contracts, known as zkApps, are also based on circuits. These circuits represent the logic and execution flow of the smart contract.  
    
- **Circuit Representation:** The circuit representation of a zkApp is generated by executing the code, not by compiling it. This means the prover function includes the execution of your code as one step.

"Internally, every @method defines a zk-SNARK circuit. From the cryptography standpoint, a smart contract is a collection of circuits, all of which are compiled into a single prover and a verification key. 
The proof says something to the effect of "I ran one of these methods, with some private input, and it produced this particular set of account updates". 

The proof is accepted on the network only if it verifies against the verification key stored in the account. 
This verification requirement ensures that the same zkApp code also ran on the end user's device and that the account updates conform to the zkApp's rules."



**Example:**

Imagine a simple zkApp that verifies a user's age without revealing their exact birthdate. The circuit would take the user's birthdate as input, calculate their age, and check if it's above a certain threshold. The proof would only reveal whether the user meets the age requirement, not their actual birthdate.

**In essence, circuit creation in Mina involves translating the desired logic into a format that can be processed by the Kimchi proof system, ensuring both privacy and efficiency.**


# Whats in a circuit


Essentially, a circuit in zkApp development represents the logic of your smart contract method, expressed in a format suitable for generating a zero-knowledge proof.

A circuit is a representation of a computation that can be verified using a zero-knowledge proof.
It's essentially a set of constraints that define the relationships between different inputs and outputs. 
These constraints are expressed as mathematical equations, specifically using arithmetic gates like addition and multiplication.  


**Arithmetic Circuits:** These circuits are fundamental to Mina and are made up of arithmetic gates (addition and multiplication).  
These [gates](https://minaprotocol.com/blog/kimchi-the-latest-update-to-minas-proof-system) can be used to represent a wide range of computations.



# Provable code


Provable code in Mina zkApps refers to the code written using the o1js library, which is designed to generate zero-knowledge proofs. These proofs provide cryptographic verification that the code has been executed correctly without revealing the private inputs used in the computation. 

The o1js library provides various methods and functions that allow developers to define constraints and assertions within their code, ensuring that these rules are enforced during proof generation.

Non-provable code, on the other hand, is regular JavaScript or TypeScript code that does not interact with the o1js library and does not contribute to the generation of the proof. This code is executed outside the proof context, meaning it cannot be verified by the Mina network.


You can think of provable code as a way to create verifiable computations that can be trusted without having to re-execute the entire computation. It's a key component of Mina's lightweight design, enabling scalability and efficiency in blockchain operations.

Making methods provable in Mina has several benefits:

● Privacy: Sensitive information used in computations remains hidden.

● Security: ZKPs provide cryptographic guarantees that the computation was performed correctly according to the defined rules.

● Scalability: Verifying a proof is much faster than re-executing the entire computation, making Mina a highly scalable blockchain.

## Why is this important ?

If code in a Mina zkApp was not provable, a malicious prover could modify the zkApp code without changing any constraints, which would allow them to bypass security measures and potentially manipulate the application for their own benefit. 

This is because a zkApp "call" effectively involves getting a proof accepted on-chain that's validated against the zkApp's verification key. If the proof is valid, it's accepted regardless of whether it was generated using the original code or a modified version that doesn't alter the constraints, but does modify the non provable part of the code.

For instance, if a zkApp relies on non-provable code to enforce access control or perform sensitive operations, a malicious user could simply remove or alter this code locally, enabling unauthorised actions without invalidating the proof. This highlights the importance of keeping all critical logic, particularly security-sensitive checks, within the provable portion of the code.



# Asserts

- Asserts are the means to check that execution is proceeding correctly

```
  //! Before a player can call this method the game needs to have started
  @method async makeGuess(unseparatedGuess: Field) {
    const isInitialized = this.account.provedState.getAndRequireEquals();
    isInitialized.assertTrue('The game has not been initialized yet!');

```


# Constraints

Asserts are the high level language features we add to our code to provide checks

```
isInitialized.assertTrue('The game has not been initialized yet!');
```

In the circuit asserts become constraints, a circuit is 'satisfied' when it's constraints are met, which means the proof is correct

There will be many constraints in the circuits, not just those derived from the assertions we have added.

There are limits to the number of constraints a circuit can contain, this limits the size and complexity of our zkApps.



