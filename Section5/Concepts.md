# zkApp Execution 

![[graphics/MINA_off_chain_computation.png | 600]]

**1. User Interaction:**

- A user interacts with a zkApp through a user interface (UI), typically within a web browser.
- The user provides inputs to the zkApp, which could include data like account balances, transaction amounts, or other relevant information.

**2. Off-chain Execution:**

- The zkApp's logic, defined as a zero-knowledge circuit using 01JS, executes within the user's browser. This is off-chain execution.
- The circuit takes the user's inputs and performs the necessary computations.

**3. Proof Generation:**

- After the computation is complete, the zkApp generates a zero-knowledge proof using the Kimchi proof system. This proof demonstrates that the computation was performed correctly without revealing the private inputs or intermediate values.

**4. Proof Submission:**

- The user submits the proof, along with any necessary public inputs, to the Mina blockchain as a transaction.

**5. On-chain Verification:**

- Mina's validators verify the proof using the corresponding verifier function, which is a concise representation of the circuit's constraints.
- Verification ensures that the computation was performed correctly and the state transition is valid.

**6. State Update:**

- If the proof is valid, the Mina blockchain updates its state accordingly. This could involve transferring tokens, updating account balances, or modifying other on-chain data.

**Key Features of zkApp Execution:**

- **Privacy:** Private inputs and intermediate values remain hidden throughout the process, preserving user privacy.
- **Efficiency:** Off-chain execution minimises on-chain computation, leading to lower transaction fees and faster processing times.
- **Scalability:** zkApps can perform complex computations without burdening the blockchain, enabling more sophisticated applications.
- **Succinctness:** Zero-knowledge proofs are compact, reducing the amount of data that needs to be stored and transmitted.

**Example:**

Imagine a zkApp for private voting. Users can cast their votes through the zkApp UI. The circuit would ensure that each user votes only once and that their vote remains secret. The proof submitted to the blockchain would only reveal the final tally of votes, not the individual choices.

**In summary, zkApp execution in Mina combines off-chain computation with on-chain verification using zero-knowledge proofs. This approach provides a powerful and efficient way to build privacy-preserving decentralised applications.**


# Circuits

## How are circuits made 


- **zkApps:** Mina's smart contracts, known as zkApps, are also based on circuits. These circuits represent the logic and execution flow of the smart contract.  
    
- **Circuit Representation:** The circuit representation of a zkApp is generated by executing the code, not by compiling it. This means the prover function includes the execution of your code as one step.

"Internally, every @method defines a zk-SNARK circuit. From the cryptography standpoint, a smart contract is a collection of circuits, all of which are compiled into a single prover and a verification key. 
The proof says something to the effect of "I ran one of these methods, with some private input, and it produced this particular set of account updates". 

The proof is accepted on the network only if it verifies against the verification key stored in the account. 
This verification requirement ensures that the same zkApp code also ran on the end user's device and that the account updates conform to the zkApp's rules."



**Example:**

Imagine a simple zkApp that verifies a user's age without revealing their exact birthdate. The circuit would take the user's birthdate as input, calculate their age, and check if it's above a certain threshold. The proof would only reveal whether the user meets the age requirement, not their actual birthdate.

**In essence, circuit creation in Mina involves translating the desired logic into a format that can be processed by the Kimchi proof system, ensuring both privacy and efficiency.**


# Whats in a circuit ? 


Essentially, a circuit in zkApp development represents the logic of your smart contract method, expressed in a format suitable for generating a zero-knowledge proof.

![[zk-circuit.png]]


A circuit is a representation of a computation that can be verified using a zero-knowledge proof.
It's essentially a set of constraints that define the relationships between different inputs and outputs. 
These constraints are expressed as mathematical equations, specifically using arithmetic gates like addition and multiplication.  


**Arithmetic Circuits:** These circuits are fundamental to Mina and are made up of arithmetic gates (addition and multiplication).  
These [gates](https://minaprotocol.com/blog/kimchi-the-latest-update-to-minas-proof-system) can be used to represent a wide range of computations.



# Provable code


Provable code in Mina zkApps refers to the code written using the o1js library, which is designed to generate zero-knowledge proofs. These proofs provide cryptographic verification that the code has been executed correctly without revealing the private inputs used in the computation. 

The o1js library provides various methods and functions that allow developers to define constraints and assertions within their code, ensuring that these rules are enforced during proof generation.

Non-provable code, on the other hand, is regular JavaScript or TypeScript code that does not interact with the o1js library and does not contribute to the generation of the proof. This code is executed outside the proof context, meaning it cannot be verified by the Mina network.


You can think of provable code as a way to create verifiable computations that can be trusted without having to re-execute the entire computation. It's a key component of Mina's lightweight design, enabling scalability and efficiency in blockchain operations.

Making methods provable in Mina has several benefits:

- Privacy: Sensitive information used in computations remains hidden.

- Security: ZKPs provide cryptographic guarantees that the computation was performed correctly according to the defined rules.

- Scalability: Verifying a proof is much faster than re-executing the entire computation, making Mina a highly scalable blockchain.


![[provable-code-method.gif]]

## Why is this important ?

If code in a Mina zkApp was not provable, a malicious prover could modify the zkApp code without changing any constraints, which would allow them to bypass security measures and potentially manipulate the application for their own benefit. 

This is because a zkApp "call" effectively involves getting a proof accepted on-chain that's validated against the zkApp's verification key. If the proof is valid, it's accepted regardless of whether it was generated using the original code or a modified version that doesn't alter the constraints, but does modify the non provable part of the code.

For instance, if a zkApp relies on non-provable code to enforce access control or perform sensitive operations, a malicious user could simply remove or alter this code locally, enabling unauthorised actions without invalidating the proof. This highlights the importance of keeping all critical logic, particularly security-sensitive checks, within the provable portion of the code.



# Asserts

- Asserts are the means to check that execution is proceeding correctly

```
  //! Before a player can call this method the game needs to have started
  @method async makeGuess(unseparatedGuess: Field) {
    const isInitialized = this.account.provedState.getAndRequireEquals();
    isInitialized.assertTrue('The game has not been initialized yet!');

```


# Constraints

Asserts are the high level language features we add to our code to provide checks

```
isInitialized.assertTrue('The game has not been initialized yet!');
```

In the circuit asserts become constraints, a circuit is 'satisfied' when it's constraints are met, which means the proof is correct

There will be many constraints in the circuits, not just those derived from the assertions we have added.

There are limits to the number of constraints a circuit can contain, this limits the size and complexity of our zkApps.

# Built in types



## Functions

### Types of Functions in a zkApp

1.  **`@method` Decorated Functions:** These are special functions within a zkApp class (usually extending the `SmartContract` class) that are designated to be part of the public interface of your zkApp.

    *   They are marked with the `@method` decorator.
    *   These functions can be called by external users or other zkApps.
    *   When called, they trigger off-chain execution and proof generation.
    *   They typically interact with and update the zkApp's on-chain state.

    ```typescript
    import { SmartContract, method, State, state } from 'o1js';

    class MyZkApp extends SmartContract {
      @state(Field) x = State<Field>();

      @method myZkAppFunction(y: Field) {
        // ... function logic, constraints, etc. ...
        const currentState = this.x.get();
        this.x.assertEquals(currentState); // Prove that we know the current state
        const newState = currentState.add(y);
        this.x.set(newState); // Update on-chain state
      }
    }
    ```

2.  **Regular Functions:** You can also define regular functions within your zkApp or in separate files for code organisation and reusability.

    *   These functions are *not* directly callable from outside the zkApp.
    *   They are used internally by `@method` functions or other helper functions.
    *   They can be inlined into the circuit (if called from a provable context) or executed normally (if called from a non-provable context).

    ```typescript
    import { Field, Provable } from 'o1js';

    // Helper function that might be inlined into the circuit
    function myHelperFunction(a: Field, b: Field): Field {
        return a.mul(b).add(1);
    }

    // Function to use in a provable context
    function myProvableFunction(x: Field): Field {
      return Provable.if(x.greaterThan(Field(5)), Field(1), Field(0));
    }
    ```

### Provable and Non-Provable Contexts

*   **Provable Context (`Provable.runAndCheck` or inside a smart contract method):** Code within this context contributes to the circuit definition and is executed during proof generation. Constraints are enforced here.  Think of this as the part of your code that gets "baked" into the zero-knowledge proof.
*   **Non-Provable Context (regular JavaScript/TypeScript code):** Code here is executed normally and does not contribute to the circuit. Constraints are not enforced. This is mainly for setup, testing or functions that don't require provable code.

### Function Arguments and Return Values in `@method` Functions

*   **Arguments:**  `@method` functions typically take arguments that are either:
    *   **Public Inputs:** These values become part of the transaction and are visible on the blockchain.
    *   **Private Inputs:** These values are part of the computation but are *not* directly stored on the blockchain. The proof demonstrates that the prover (the one executing the function) knew these values and used them correctly, but the values themselves remain hidden.
*   **Return Values:** `@method` functions in the current version of Mina generally do not have return values in the traditional sense. Instead of returning data, they achieve their effects by:
    *   **Updating On-Chain State:**  Modifying the zkApp's state variables, which are stored on the blockchain.
    *   **Emitting Events:** These are notifications that something happened during the execution of the function, which can be observed by external parties but do not change the state.
    *   **Failing:** If a constraint is violated or an assertion fails during the execution, the function call will effectively fail and revert any changes to the state.

**Example**

```typescript
import {
  Field,
  SmartContract,
  state,
  State,
  method,
  PrivateKey,
  PublicKey,
  Mina,
  AccountUpdate,
  Provable,
  assert,
} from 'o1js';

class SimpleZkApp extends SmartContract {
  @state(Field) num = State<Field>();

  @method init() {
    super.init();
    this.num.set(Field(1));
  }

  @method update(increment: Field) {
    const currentNum = this.num.get();
    this.num.assertEquals(currentNum); // Prove knowledge of the current state value

    // Using a helper function to calculate the new value
    const newNum = calculateNewValue(currentNum, increment);

    // Asserting a condition before updating the state
    newNum.assertLessThan(Field(100), "New value must be less than 100");

    this.num.set(newNum);
  }
}

// Regular helper function (might be inlined into the circuit)
function calculateNewValue(current: Field, increment: Field): Field {
  return current.add(increment);
}
```

**In summary:** Functions in Mina are the core of zkApp logic. `@method` functions define the publicly callable interface and trigger off-chain execution and proof generation. Regular functions help with code organisation. Understanding the distinction between provable and non-provable contexts is crucial. While `@method` functions don't have return values, they update on-chain state, emit events, or fail to signal results. These features enable Mina's unique properties of scalability, privacy, and verifiability.