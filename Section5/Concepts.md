# zkApp Execution 

![[graphics/MINA_off_chain_computation.png | 600]]

**1. User Interaction:**

- A user interacts with a zkApp through a user interface (UI), typically within a web browser.
- The user provides inputs to the zkApp, which could include data like account balances, transaction amounts, or other relevant information.

**2. Off-chain Execution:**

- The zkApp's logic, defined as a zero-knowledge circuit using 01JS, executes within the user's browser. This is off-chain execution.
- The circuit takes the user's inputs and performs the necessary computations.

**3. Proof Generation:**

- After the computation is complete, the zkApp generates a zero-knowledge proof using the Kimchi proof system. This proof demonstrates that the computation was performed correctly without revealing the private inputs or intermediate values.

**4. Proof Submission:**

- The user submits the proof, along with any necessary public inputs, to the Mina blockchain as a transaction.

**5. On-chain Verification:**

- Mina's validators verify the proof using the corresponding verifier function, which is a concise representation of the circuit's constraints.
- Verification ensures that the computation was performed correctly and the state transition is valid.

**6. State Update:**

- If the proof is valid, the Mina blockchain updates its state accordingly. This could involve transferring tokens, updating account balances, or modifying other on-chain data.

**Key Features of zkApp Execution:**

- **Privacy:** Private inputs and intermediate values remain hidden throughout the process, preserving user privacy.
- **Efficiency:** Off-chain execution minimises on-chain computation, leading to lower transaction fees and faster processing times.
- **Scalability:** zkApps can perform complex computations without burdening the blockchain, enabling more sophisticated applications.
- **Succinctness:** Zero-knowledge proofs are compact, reducing the amount of data that needs to be stored and transmitted.

**Example:**

Imagine a zkApp for private voting. Users can cast their votes through the zkApp UI. The circuit would ensure that each user votes only once and that their vote remains secret. The proof submitted to the blockchain would only reveal the final tally of votes, not the individual choices.

**In summary, zkApp execution in Mina combines off-chain computation with on-chain verification using zero-knowledge proofs. This approach provides a powerful and efficient way to build privacy-preserving decentralised applications.**


# Circuits

## How are circuits made 


- **zkApps:** Mina's smart contracts, known as zkApps, are also based on circuits. These circuits represent the logic and execution flow of the smart contract.  
    
- **Circuit Representation:** The circuit representation of a zkApp is generated by executing the code, not by compiling it. This means the prover function includes the execution of your code as one step.

"Internally, every @method defines a zk-SNARK circuit. From the cryptography standpoint, a smart contract is a collection of circuits, all of which are compiled into a single prover and a verification key. 
The proof says something to the effect of "I ran one of these methods, with some private input, and it produced this particular set of account updates". 

The proof is accepted on the network only if it verifies against the verification key stored in the account. 
This verification requirement ensures that the same zkApp code also ran on the end user's device and that the account updates conform to the zkApp's rules."



**Example:**

Imagine a simple zkApp that verifies a user's age without revealing their exact birthdate. The circuit would take the user's birthdate as input, calculate their age, and check if it's above a certain threshold. The proof would only reveal whether the user meets the age requirement, not their actual birthdate.

**In essence, circuit creation in Mina involves translating the desired logic into a format that can be processed by the Kimchi proof system, ensuring both privacy and efficiency.**


# Whats in a circuit ? 


Essentially, a circuit in zkApp development represents the logic of your smart contract method, expressed in a format suitable for generating a zero-knowledge proof.

![[zk-circuit.png]]


A circuit is a representation of a computation that can be verified using a zero-knowledge proof.
It's essentially a set of constraints that define the relationships between different inputs and outputs. 
These constraints are expressed as mathematical equations, specifically using arithmetic gates like addition and multiplication.  


**Arithmetic Circuits:** These circuits are fundamental to Mina and are made up of arithmetic gates (addition and multiplication).  
These [gates](https://minaprotocol.com/blog/kimchi-the-latest-update-to-minas-proof-system) can be used to represent a wide range of computations.



# Provable code


Provable code in Mina zkApps refers to the code written using the o1js library, which is designed to generate zero-knowledge proofs. These proofs provide cryptographic verification that the code has been executed correctly without revealing the private inputs used in the computation. 

The o1js library provides various methods and functions that allow developers to define constraints and assertions within their code, ensuring that these rules are enforced during proof generation.

Non-provable code, on the other hand, is regular JavaScript or TypeScript code that does not interact with the o1js library and does not contribute to the generation of the proof. This code is executed outside the proof context, meaning it cannot be verified by the Mina network.


You can think of provable code as a way to create verifiable computations that can be trusted without having to re-execute the entire computation. It's a key component of Mina's lightweight design, enabling scalability and efficiency in blockchain operations.

Making methods provable in Mina has several benefits:

- Privacy: Sensitive information used in computations remains hidden.

- Security: ZKPs provide cryptographic guarantees that the computation was performed correctly according to the defined rules.

- Scalability: Verifying a proof is much faster than re-executing the entire computation, making Mina a highly scalable blockchain.


![[provable-code-method.gif]]

## Why is this important ?

If code in a Mina zkApp was not provable, a malicious prover could modify the zkApp code without changing any constraints, which would allow them to bypass security measures and potentially manipulate the application for their own benefit. 

This is because a zkApp "call" effectively involves getting a proof accepted on-chain that's validated against the zkApp's verification key. If the proof is valid, it's accepted regardless of whether it was generated using the original code or a modified version that doesn't alter the constraints, but does modify the non provable part of the code.

For instance, if a zkApp relies on non-provable code to enforce access control or perform sensitive operations, a malicious user could simply remove or alter this code locally, enabling unauthorised actions without invalidating the proof. This highlights the importance of keeping all critical logic, particularly security-sensitive checks, within the provable portion of the code.



# Asserts

- Asserts are the means to check that execution is proceeding correctly

```
  //! Before a player can call this method the game needs to have started
  @method async makeGuess(unseparatedGuess: Field) {
    const isInitialized = this.account.provedState.getAndRequireEquals();
    isInitialized.assertTrue('The game has not been initialized yet!');

```


# Constraints

Asserts are the high level language features we add to our code to provide checks

```
isInitialized.assertTrue('The game has not been initialized yet!');
```

In the circuit asserts become constraints, a circuit is 'satisfied' when it's constraints are met, which means the proof is correct

There will be many constraints in the circuits, not just those derived from the assertions we have added.

There are limits to the number of constraints a circuit can contain, this limits the size and complexity of our zkApps.

# Built in types



## Functions

### Types of Functions in a zkApp

1.  **`@method` Decorated Functions:** These are special functions within a zkApp class (usually extending the `SmartContract` class) that are designated to be part of the public interface of your zkApp.

    *   They are marked with the `@method` decorator.
    *   These functions can be called by external users or other zkApps.
    *   When called, they trigger off-chain execution and proof generation.
    *   They typically interact with and update the zkApp's on-chain state.

    ```typescript
    import { SmartContract, method, State, state } from 'o1js';

    class MyZkApp extends SmartContract {
      @state(Field) x = State<Field>();

      @method myZkAppFunction(y: Field) {
        // ... function logic, constraints, etc. ...
        const currentState = this.x.get();
        this.x.assertEquals(currentState); // Prove that we know the current state
        const newState = currentState.add(y);
        this.x.set(newState); // Update on-chain state
      }
    }
    ```

2.  **Regular Functions:** You can also define regular functions within your zkApp or in separate files for code organisation and reusability.

    *   These functions are *not* directly callable from outside the zkApp.
    *   They are used internally by `@method` functions or other helper functions.
    *   They can be inlined into the circuit (if called from a provable context) or executed normally (if called from a non-provable context).

    ```typescript
    import { Field, Provable } from 'o1js';

    // Helper function that might be inlined into the circuit
    function myHelperFunction(a: Field, b: Field): Field {
        return a.mul(b).add(1);
    }

    // Function to use in a provable context
    function myProvableFunction(x: Field): Field {
      return Provable.if(x.greaterThan(Field(5)), Field(1), Field(0));
    }
    ```

### Provable and Non-Provable Contexts

*   **Provable Context (`Provable.runAndCheck` or inside a smart contract method):** Code within this context contributes to the circuit definition and is executed during proof generation. Constraints are enforced here.  Think of this as the part of your code that gets "baked" into the zero-knowledge proof.
*   **Non-Provable Context (regular JavaScript/TypeScript code):** Code here is executed normally and does not contribute to the circuit. Constraints are not enforced. This is mainly for setup, testing or functions that don't require provable code.

### Function Arguments and Return Values in `@method` Functions

*   **Arguments:**  `@method` functions typically take arguments that are either:
    *   **Public Inputs:** These values become part of the transaction and are visible on the blockchain.
    *   **Private Inputs:** These values are part of the computation but are *not* directly stored on the blockchain. The proof demonstrates that the prover (the one executing the function) knew these values and used them correctly, but the values themselves remain hidden.
*   **Return Values:** `@method` functions in the current version of Mina generally do not have return values in the traditional sense. Instead of returning data, they achieve their effects by:
    *   **Updating On-Chain State:**  Modifying the zkApp's state variables, which are stored on the blockchain.
    *   **Emitting Events:** These are notifications that something happened during the execution of the function, which can be observed by external parties but do not change the state.
    *   **Failing:** If a constraint is violated or an assertion fails during the execution, the function call will effectively fail and revert any changes to the state.

**Example**

```typescript
import {
  Field,
  SmartContract,
  state,
  State,
  method,
  PrivateKey,
  PublicKey,
  Mina,
  AccountUpdate,
  Provable,
  assert,
} from 'o1js';

class SimpleZkApp extends SmartContract {
  @state(Field) num = State<Field>();

  @method init() {
    super.init();
    this.num.set(Field(1));
  }

  @method update(increment: Field) {
    const currentNum = this.num.get();
    this.num.assertEquals(currentNum); // Prove knowledge of the current state value

    // Using a helper function to calculate the new value
    const newNum = calculateNewValue(currentNum, increment);

    // Asserting a condition before updating the state
    newNum.assertLessThan(Field(100), "New value must be less than 100");

    this.num.set(newNum);
  }
}

// Regular helper function (might be inlined into the circuit)
function calculateNewValue(current: Field, increment: Field): Field {
  return current.add(increment);
}
```

**In summary:** Functions in Mina are the core of zkApp logic. `@method` functions define the publicly callable interface and trigger off-chain execution and proof generation. Regular functions help with code organisation. Understanding the distinction between provable and non-provable contexts is crucial. While `@method` functions don't have return values, they update on-chain state, emit events, or fail to signal results. These features enable Mina's unique properties of scalability, privacy, and verifiability.


## Conditionals

Conditionals in Mina, similar to other programming languages, allow you to control the flow of execution in your zkApp code based on certain conditions. However, because Mina uses zero-knowledge proofs and relies on circuit-based computations, conditionals have some specific characteristics and limitations compared to traditional programming.

**Key Concepts**

1. **Circuit Compatibility:** Conditionals in Mina must be compatible with the circuit representation of your zkApp's logic. This means that the conditions and the code executed within each branch of the conditional must be expressible as constraints within the circuit.
2. **Provable.if:** The primary way to express conditionals within a provable context (inside `@method` functions or `Provable.runAndCheck`) is using the `Provable.if` function. This function allows you to select between two values based on a `Bool` condition, all within the constraints of the circuit.
3. **In-Circuit Execution:** When you use `Provable.if`, both branches of the conditional are effectively "executed" in the sense that they are evaluated and contribute to the circuit's constraints. However, the constraints ensure that only the result of the chosen branch is used in subsequent computations.

**Provable.if**

The `Provable.if` function is the cornerstone of conditionals in Mina's provable code. Here's how it works:

TypeScript

```
Provable.if(condition: Bool, then: T, else: T): T
```

- `condition`: A `Bool` value that determines which branch is selected.
- `then`: The value to be returned if the `condition` is `true`.
- `else`: The value to be returned if the `condition` is `false`.
- `T`: The type of the `then` and `else` values, which must be the same. This can be any type that is compatible with o1js and circuit constraints (e.g., `Field`, `Bool`, custom structures, etc.)

**Example**

TypeScript

```
import { Field, Bool, Provable } from 'o1js';

let x = Field(10);
let y = Field(5);

let result = Provable.if(x.greaterThan(y), x, y); // Select the larger value

Provable.log('Result:', result); // Output will be 10
```

**How Provable.if Works in the Circuit**

Internally, `Provable.if` uses a "selector" mechanism to choose the appropriate value. It essentially creates constraints that look like this (simplified):

```
result = condition * then + (1 - condition) * else
```

- If `condition` is true (1), then `result` will be equal to `then`.
- If `condition` is false (0), then `result` will be equal to `else`.

**Important Considerations**

4. **Both Branches are Evaluated:** Keep in mind that both `then` and `else` expressions in `Provable.if` are evaluated in the sense that they contribute to the circuit. The constraints ensure that only the relevant result is used, but both branches have a computational cost. This can impact performance, especially in nested conditionals.
    
5. **Circuit Size:** Complex conditionals with many branches or nested `Provable.if` statements can lead to larger circuits, which might affect proof generation time.
    
6. **Side Effects:** Avoid side effects (like updating state or emitting events) within the branches of `Provable.if` if you are not sure of the context. It's generally recommended to keep the branches focused on calculating values and to handle side effects outside the conditional. Using side-effects is allowed, but it makes the code less readable and more prone to have non-intended behavior.
    
7. **Alternatives for Complex Logic:** For very complex conditional logic, you might consider alternative approaches like:
    
    - **Lookup Tables:** If the condition depends on a limited set of possible values, you can precompute the results and use a lookup table within the circuit.
    - **Specialized Gadgets:** For certain common patterns, o1js might provide specialized "gadgets" (optimized functions) that can handle conditional logic more efficiently.
    - **Refactoring:** Sometimes, you can refactor your code to reduce the need for complex conditionals in the first place.

**Conditionals Outside Provable Context**

In the non-provable parts of your Mina code (outside `@method` functions and `Provable.runAndCheck`), you can use regular JavaScript/TypeScript `if`, `else if`, and `else` statements as you normally would. These conditionals do not affect the circuit and are executed normally.

**Example: Conditional State Update**

TypeScript

```
import { Field, SmartContract, state, State, method, Bool, Provable } from 'o1js';

class MyZkApp extends SmartContract {
  @state(Field) value = State<Field>();

  @method myConditionalUpdate(x: Field, condition: Bool) {
    const currentValue = this.value.get();
    this.value.assertEquals(currentValue);

    const newValue = Provable.if(condition, x, currentValue);

    this.value.set(newValue);
  }
}
```

**In Summary**

Conditionals in Mina are primarily handled by `Provable.if` within provable contexts. This function allows for circuit-compatible conditional logic, where both branches are evaluated but only the chosen result is used. While powerful, it's important to be mindful of circuit size and potential performance implications when using complex conditionals in your zkApps. Using regular `if` statements is possible in non-provable sections of the code. Understanding these nuances is essential for writing efficient and correct provable code in Mina.


# Storage Overview

Mina's zkApps utilize a unique approach to storage, combining on-chain and off-chain solutions to manage data efficiently.

**On-Chain Storage:**

- **Limited Capacity:** Each zkApp account has 8 fields, each holding approximately 32 bytes of data. This is suitable for storing essential parameters, root hashes of larger datasets, or small pieces of information.
- **Fast Access:** On-chain storage is readily accessible within the zkApp, enabling efficient interaction with core application data.
- **Security:** Data stored on-chain benefits from the inherent security of the Mina blockchain.

**Off-Chain Storage:**

- **Scalability:** For larger datasets, zkApps rely on off-chain storage solutions. This can involve decentralised storage systems like IPFS, or even traditional centralized servers.
- **Flexibility:** Developers have the freedom to choose the off-chain storage that best suits their needs and application requirements.
- **Cost-Effectiveness:** Off-chain storage is generally more cost-effective than storing large amounts of data directly on the blockchain.

**Bridging On-Chain and Off-Chain:**

- **Commitment Schemes:** zkApps typically use commitment schemes (like Merkle trees) to link on-chain and off-chain data. The root hash of the off-chain data structure is stored on-chain, providing a verifiable link to the complete dataset.

**Example:**

Imagine a zkApp for a decentralised social media platform. User profiles, posts, and images could be stored off-chain in IPFS. The zkApp would store the root hash of this data on-chain. When a user wants to view a post, the zkApp can use zk-SNARKs to prove that the post data is consistent with the committed root hash stored on the blockchain.

By combining the strengths of both on-chain and off-chain storage, Mina zkApps can achieve a good balance of functionality, security, and cost-effectiveness.

![[off_chain_on_chain_storage.png]]
# Off chain versus on chain

**On-Chain Storage**

- **Features:**
    - **Limited Capacity:** Each zkApp account has 8 fields, each holding about 32 bytes of data.2
    - **Fast Access:** Data is readily available within the zkApp
    - **High Security:** Benefits from the blockchain's inherent security.
    - **Transparency:** Data is publicly viewable on the Mina blockchain.
- **Use Cases:**
    - Storing crucial application parameters.
    - Storing root hashes of larger off-chain datasets (using Merkle trees or similar).4
    - Holding small, critical pieces of information.
    - Managing token balances and ownership.

**Off-Chain Storage**

- **Features:**
    - **Scalability:** Handles large datasets that wouldn't fit on-chain.
    - **Flexibility:** Developers choose the storage solution (IPFS, centralized servers, etc.).
    - **Cost-Effectiveness:** Generally cheaper than on-chain storage.
    - **Privacy:** Can be used to store sensitive data that shouldn't be public.
- **Use Cases:**
    - Storing large files (images, videos, documents).
    - Managing extensive user databases.
    - Handling complex data structures.
    - Archiving historical data.


**How They Work Together**

- **Commitment Schemes:** zkApps typically use commitment schemes (like Merkle trees) to link on-chain and off-chain data. The root hash of the off-chain data is stored on-chain, providing a verifiable link to the off-chain data.

**Example:**

A zkApp for a decentralised exchange (DEX) might store the current order book off-chain. The on-chain storage would hold the Merkle root of this order book. When a user places an order, the zkApp would generate a zk-SNARK proof to verify that the new order is valid and included in the updated off-chain order book.

By combining the strengths of both on-chain and off-chain storage, Mina zkApps can achieve a good balance of functionality, security, and cost-effectiveness.



# Recursion

![Screenshot_20241031_105406.png](app://c53887f8d538cb3a76eb9e00ce1d6e219d4c/Users/extropy/Work/Dev/MinaCertificationMaterial/img/Screenshot_20241031_105406.png?1730373609421)

We have seen how Mina uses recursive proofs at the protocol level to produce a constant size succinct blockchain.

Within the blocks recursion is used to compress transactions down to a constant size.

On top of the protocol, we can use recursion when writing our zkApps.

As part of our zkApp we can verify a zero knowledge program.

We do this using `zkProgram`

See [ZKProgram Overview](https://docs.minaprotocol.com/zkapps/o1js/recursion#zkprogram-overview)

## Recursion in zkApps

Mina's zkApps uniquely support recursion, allowing you to verify any zero-knowledge program as part of your zkApp. This powerful feature unlocks several advanced capabilities, including:

• Verifying complex computations: Recursion allows you to break down large computations into smaller, verifiable steps. Each step generates a proof, and these proofs can be recursively combined into a single proof for the entire computation.

• Building zkRollups and app chains: ZkRollups are Layer-2 scaling solutions that bundle multiple transactions off-chain and generate a single proof for their validity. App chains are application-specific blockchains built on top of Mina. Both leverage recursion to efficiently verify large numbers of transactions.

• Facilitating multi-party computation: Multiple parties can contribute to a computation by recursively updating a zero-knowledge proof. This enables secure off-chain collaboration and data sharing.

# Nullifiers

A nullifier is a cryptographic tool used to represent a unique anonymous account. It's like a secret code that proves a specific action was taken by a particular account without revealing the account's identity. Imagine a voting system where you want to ensure everyone votes only once, but keep their votes anonymous. Nullifiers can achieve this:

Nullifiers are particularly useful for:

• Preventing double-spending: Ensuring someone can't spend the same digital currency twice.

• Maintaining consistent identity across actions: Allowing an anonymous user to interact with a zkApp multiple times while preserving their anonymity.

![[nullifiers_n.png]]
## o1js support

In o1js a nullifier is implemented as a provable data structure.

It has the following properties:

• Private components: These are secret values used to generate the nullifier and verify its correctness.

• Public components: These are values publicly associated with the nullifier.

• Public key: This is the public key associated with the anonymous account represented by the nullifier.

## o1js methods for nullifiers

These include

• assertUnused() and isUnused(): Check if the nullifier has been previously used, which is essential for preventing double-spending or multiple actions.

• getPublicKey(): Retrieves the public key associated with the nullifier.

• setUsed(): Marks the nullifier as used, updating the associated Merkle tree.

• verify(): Ensures the nullifier was generated correctly for a specific message, preventing tampering.


# Custom Tokens

Mina supports custom tokens at a low level in the tech stack, treating them almost the same way as the native MINA token.  
This approach offers several advantages, including reducing the need for boilerplate contracts and simplifying account and balance management for developers.

Each account on Mina can have tokens associated with it, and zkApps can be built to interact with these tokens, facilitating actions such as token swaps

The rules for custom token operations are defined within a token manager smart contract.

A token manager smart contract is a standard smart contract utilising the TokenContract class to manipulate tokens.  
This contract defines the rules for actions like minting, burning, and sending custom tokens

• Minting generates new tokens and adds them to an account's balance.

• Burning removes tokens from an account's balance.

• Sending transfers tokens between two accounts and requires zkApp approval.

The token manager account can assign a token symbol, like "MYTKN", for its token.  
Uniqueness is not enforced for token names because each token has a unique identifier derived from the public key of the managing account.

Key terms for custom tokens:

• Token ID: Unique identifiers for different custom tokens, derived from a zkApp. You can check a zkApp's token ID using `this.token.id`

• Token accounts: Similar to regular accounts but hold the balance of a specific custom token instead of MINA.  
These accounts are created from existing accounts and are identified by a public key and a token ID.


# Private Credentials and Attestations

Mina has a Private Credentials API on its product roadmap, which will offer a standardised interface for issuing credentials and proving attestations of private credentials to verifiers

This would provide a standardised way for users to receive credentials and prove they hold those credentials without revealing the underlying data.

Imagine having digital versions of your driver's license, university degree, or professional certifications, all stored securely in your Mina wallet.


![[private-credentials.png]]
## Attestations

In Mina, an attestation is a statement that someone has proven something in a zero-knowledge proof. For example, an attestation could be a statement that you are over 18 or that you hold a valid driver's license. The beauty of zero-knowledge proofs is that you can prove these statements without revealing the underlying data.  
So, you could prove that you're over 18 without revealing your birth date, or prove you hold a driver's license without revealing your license number.

Mina is actively working on establishing a robust Private Credential Standard to ensure the secure and efficient implementation of this functionality.

The current proposals for Private credentials and attestations outlines a system where credentials would be composed of different types of attestations, including Mina-compatible signatures and recursive proofs.

This approach leverages Mina's strengths in zero-knowledge cryptography, particularly its support for recursive proofs, which allows for the verification of complex statements built upon other proofs


# Authorisation and Permissions

Authorisation and permissions are crucial for securing zkApp accounts on Mina.

## Permissions

Permissions define the authorisation level needed to perform actions on a zkApp account.

## Authorisation

Authorisation specifies the validation type required for an account update to be permitted and is checked whenever an account is accessed.

### Types of Authorisation

Mina uses the following authorisation types:

- none: Open access; anyone can manipulate the field.
    
- impossible: The field is immutable and can never be modified.
    
- signature: Requires a valid signature from the account owner for authorisation.
    
- proof: Requires a valid zero-knowledge proof generated by executing a zkApp method, validated against the account's verification key.
    
- proofOrSignature: Accepts either a valid signature or a valid proof.
    

### Default Permissions

Newly deployed zkApp contracts begin with default permissions designed for development but should be adjusted for production.

Two default permissions require particular attention:

1. setVerificationKey: signature: Allows the account owner to change the zkApp's code at any time using only their signature. This is convenient for development but poses a security risk in production. For production, set setVerificationKey to impossible to prevent upgrades or to proof to enable upgrades only through a secure protocol requiring a valid zero-knowledge proof.
    
2. setPermissions: signature: Allows the account owner to change permissions using only their signature, potentially overriding other security measures. This permission should be carefully managed and locked down to prevent arbitrary changes to the zkApp's security settings.

---



# Transactions and Account Updates

In Mina, when users interact with a zkApp, they generate a transaction that encapsulates the results of their interaction. These transactions, composed of account updates, are sent to the Mina network for validation and application.

- Transaction
    
    - A JSON object containing a list of account updates, a fee payer, and an optional memo.
        
    - The fee payer is the account responsible for covering the transaction fee.
        
    - The account updates list describes all the modifications to be made to various accounts.
        
    - The memo is an optional field for attaching a short message to the transaction.
        
- Account Update
    
    - Contains updates for a single specific account.
        
    - Includes:
        
        - PublicKey: The address of the account being updated.
            
        - TokenId: A unique hash representing the token associated with the update. Defaults to the native MINA token.
            
        - Preconditions: Conditions that must be met for the update to be applied.
            
        - Updates: The actual changes being made to the account.
            
        - BalanceChange: Changes to the account's balance, either positive or negative.
            
        - Authorization: How the update is authorized can be a proof (for zkApp accounts), a signature (for user accounts), or none (for updates that don't require authorization).
            



--- 

# State Update

A state update refers to any modification to the on-chain data associated with a zkApp account. Each zkApp account has 8 fields, each able to store approximately 32 bytes of arbitrary data. This on-chain storage is referred to as a zkApp's "state".

To modify this state, you need to use a transaction. Transactions are bundles of instructions sent to the Mina network. These instructions are formatted as account updates, which describe exactly how specific accounts should be changed.

Within a transaction, account updates can target different aspects of a zkApp account:

- appState: The core on-chain state of a zkApp. Modified using the this.&lt;state>.set() method within zkApp code.
    
- permissions: Permissions control who can do what with your zkApp. They can be modified using this.&lt;permission>.set().
    
- verificationKey: The cryptographic key used to verify proofs generated by your zkApp. You can upgrade your zkApp by changing this key.

![[state_update_current_state.png]]
![[state_update_example.png]]


When you call a @method within your zkApp, it implicitly creates an account update targeting the zkApp account itself. This update will include changes to the appState based on your code, and it will be authorised using a proof generated from the execution of your @method.

State updates only occur when a valid transaction containing the proof is accepted by the network. This ensures the integrity and consistency of the zkApp's state.

State updates occur when a zkApp's data on the blockchain is modified. This modification is facilitated through transactions that include proof of correct execution generated by the zkApp.


---

# Preconditions

A precondition in Mina is a condition that must be met for a transaction, or account update, to be applied on the Mina blockchain. It is essentially a rule that needs to be satisfied for the transaction to be deemed valid.

At the heart of Mina transactions lies the concept of an "account update". An account update serves as a set of instructions for the Mina network, detailing changes to be made to a specific account on the blockchain. These updates encompass modifications to the account's balance, state, and other relevant attributes.


![[preconditions.png]]
Think of a precondition as a safeguard, ensuring that only legitimate updates are applied to an account. Before an account update is processed, the preconditions are examined. Only if these preconditions are met will the update be accepted and the changes implemented on the blockchain.